# 파이썬 패킹(Packing)과 언패킹(Unpacking) 완벽 가이드

## 목차
1. [기본 개념](#기본-개념)
2. [변수 언패킹](#변수-언패킹)
3. [함수와 패킹/언패킹](#함수와-패킹언패킹)
4. [심화 주제](#심화-주제)
5. [실전 예제](#실전-예제)
6. [주의사항 및 베스트 프랙티스](#주의사항-및-베스트-프랙티스)

---

## 기본 개념

### 패킹(Packing)이란?
**패킹**은 여러 개의 값을 하나의 컨테이너(리스트, 튜플 등)에 묶는 과정입니다.

```python
# 기본 패킹
values = 1, 2, 3  # 튜플로 자동 패킹됨
print(values)  # (1, 2, 3)
print(type(values))  # <class 'tuple'>

# 명시적 패킹
values = (1, 2, 3)
values = [1, 2, 3]
```

### 언패킹(Unpacking)이란?
**언패킹**은 컨테이너에 담긴 값들을 개별 변수에 할당하는 과정입니다.

```python
# 기본 언패킹
values = (1, 2, 3)
a, b, c = values
print(a, b, c)  # 1 2 3

# 리스트 언패킹
values = [10, 20, 30]
x, y, z = values
print(x, y, z)  # 10 20 30
```

---

## 변수 언패킹

### 1. 기본 언패킹

```python
# 동일한 개수의 값과 변수
a, b, c = 1, 2, 3
print(f"a={a}, b={b}, c={c}")  # a=1, b=2, c=3

# 서로 다른 타입도 가능
name, age, active = "Alice", 30, True
print(f"{name} is {age} years old")  # Alice is 30 years old

# 중첩된 시퀀스
(x, y), z = (1, 2), 3
print(x, y, z)  # 1 2 3
```

### 2. 확장 언패킹 (Extended Unpacking)

확장 언패킹은 `*` 연산자를 사용하여 여러 값을 한 변수에 할당합니다.

```python
# 남은 값들을 수집
a, *rest = [1, 2, 3, 4, 5]
print(f"a={a}, rest={rest}")  # a=1, rest=[2, 3, 4, 5]

# 앞과 뒤에서 수집
first, *middle, last = [1, 2, 3, 4, 5]
print(f"first={first}, middle={middle}, last={last}")  
# first=1, middle=[2, 3, 4], last=5

# 무시하고 싶은 값에는 _를 사용
first, _, *rest = [1, 2, 3, 4, 5]
print(f"first={first}, rest={rest}")  # first=1, rest=[3, 4, 5]

# 한 번만 사용 가능 (여러 *는 불가)
# a, *b, *c = [1, 2, 3, 4, 5]  # SyntaxError
```

### 3. 중첩 언패킹

```python
# 리스트 안의 리스트
(a, b), (c, d) = [1, 2], [3, 4]
print(a, b, c, d)  # 1 2 3 4

# 복합 패턴
(x, [y, z]), w = (1, [2, 3]), 4
print(x, y, z, w)  # 1 2 3 4

# 중첩된 확장 언패킹
(first, *middle, last), rest = ([1, 2, 3, 4], 5)
print(first, middle, last, rest)  # 1 [2, 3] 4 5
```

### 4. 호환성 요구사항

```python
# 값의 개수와 변수의 개수가 일치해야 함
a, b = [1, 2, 3]  # ValueError: too many values to unpack (expected 2)

# 하지만 *를 사용하면 가능
a, *rest = [1, 2, 3]  # 성공

# 최소 개수 확인
first, *middle, last = [1]  # ValueError: not enough values to unpack (expected at least 2, got 1)
```

---

## 함수와 패킹/언패킹

### 1. 함수 인자 패킹

#### `*args` (Positional Argument Packing)

```python
# 가변 위치 인자
def print_items(*args):
    """여러 개의 위치 인자를 받음"""
    print(f"args 타입: {type(args)}")  # <class 'tuple'>
    for i, item in enumerate(args):
        print(f"  {i}: {item}")

print_items(1, 2, 3, "hello")
# args 타입: <class 'tuple'>
#   0: 1
#   1: 2
#   2: 3
#   3: hello

# args 개수가 가변적
print_items(1)
print_items()
```

#### `**kwargs` (Keyword Argument Packing)

```python
# 가변 키워드 인자
def print_person(**kwargs):
    """여러 개의 키워드 인자를 받음"""
    print(f"kwargs 타입: {type(kwargs)}")  # <class 'dict'>
    for key, value in kwargs.items():
        print(f"  {key}: {value}")

print_person(name="Alice", age=30, city="Seoul")
# kwargs 타입: <class 'dict'>
#   name: Alice
#   age: 30
#   city: Seoul
```

#### `*args`와 `**kwargs` 조합

```python
def flexible_function(a, b, *args, **kwargs):
    """위치 인자, *args, 키워드 인자 모두 받음"""
    print(f"a={a}, b={b}")
    print(f"args={args}")
    print(f"kwargs={kwargs}")

flexible_function(1, 2, 3, 4, x=10, y=20)
# a=1, b=2
# args=(3, 4)
# kwargs={'x': 10, 'y': 20}
```

### 2. 함수 호출 시 언패킹

#### 리스트/튜플 언패킹

```python
def add(a, b, c):
    return a + b + c

# 리스트/튜플을 인자로 언패킹
numbers = [1, 2, 3]
result = add(*numbers)
print(result)  # 6

# 여러 시퀀스 언패킹
def print_coords(x, y, z):
    print(f"좌표: ({x}, {y}, {z})")

coords = [10, 20]
extra = [30]
print_coords(*coords, *extra)  # 좌표: (10, 20, 30)
```

#### 딕셔너리 언패킹

```python
def greet(name, age, city):
    print(f"{name}은 {age}세이고 {city}에 삽니다.")

person = {"name": "Bob", "age": 25, "city": "Busan"}
greet(**person)  # Bob은 25세이고 Busan에 삽니다.

# 부분 언패킹
person_data = {"name": "Charlie", "age": 35}
greet(**person_data, city="Daegu")  # Charlie은 35세이고 Daegu에 삽니다.
```

### 3. 패킹과 언패킹의 조합

```python
# 함수에서 패킹된 데이터를 언패킹하여 다른 함수로 전달
def outer_function(*args, **kwargs):
    """데이터를 받아서 inner_function으로 전달"""
    inner_function(*args, **kwargs)

def inner_function(a, b, c=0):
    print(f"a={a}, b={b}, c={c}")

# 사용
outer_function(1, 2, c=3)  # a=1, b=2, c=3
```

---

## 심화 주제

### 1. 딕셔너리 병합과 언패킹

```python
# Python 3.9+에서 딕셔너리 언패킹으로 병합
dict1 = {"a": 1, "b": 2}
dict2 = {"c": 3, "d": 4}

# 방법 1: 언패킹 (Python 3.9+)
merged = {**dict1, **dict2}
print(merged)  # {'a': 1, 'b': 2, 'c': 3, 'd': 4}

# 방법 2: 오버라이드
dict3 = {"a": 10, "e": 5}
merged = {**dict1, **dict3}
print(merged)  # {'a': 10, 'b': 2, 'e': 5}

# 방법 3: 리스트 언패킹으로 딕셔너리 생성
keys = ["name", "age", "city"]
values = ["David", 28, "Seoul"]
person_dict = dict(zip(keys, values))
print(person_dict)  # {'name': 'David', 'age': 28, 'city': 'Seoul'}
```

### 2. 클래스와 언패킹

```python
# 언패킹으로 클래스 초기화
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

# 리스트 언패킹
coords = [10, 20]
point = Point(*coords)
print(point)  # Point(10, 20)

# 딕셔너리 언패킹
point_data = {"x": 30, "y": 40}
point2 = Point(**point_data)
print(point2)  # Point(30, 40)
```

### 3. 고급 패턴

```python
# 패턴 매칭 (Python 3.10+)
def process_data(data):
    match data:
        case [x]:
            print(f"단일 값: {x}")
        case [x, y]:
            print(f"두 개 값: {x}, {y}")
        case [first, *rest]:
            print(f"첫 번째: {first}, 나머지: {rest}")
        case _:
            print("기타")

process_data([1])  # 단일 값: 1
process_data([1, 2])  # 두 개 값: 1, 2
process_data([1, 2, 3, 4])  # 첫 번째: 1, 나머지: [2, 3, 4]

# 컴프리헨션과 언패킹
pairs = [(1, 2), (3, 4), (5, 6)]
flattened = [x for pair in pairs for x in pair]
print(flattened)  # [1, 2, 3, 4, 5, 6]

# 언패킹을 이용한 컴프리헨션
results = [x + y for x, y in pairs]
print(results)  # [3, 7, 11]
```

---

## 실전 예제

### 예제 1: CSV 파일 처리

```python
# CSV 데이터 처리
csv_data = [
    "홍길동,30,서울",
    "김영희,25,부산",
    "이순신,35,대구"
]

for line in csv_data:
    name, age, city = line.split(",")
    print(f"{name}: {age}세, {city} 거주")

# 출력:
# 홍길동: 30세, 서울 거주
# 김영희: 25세, 부산 거주
# 이순신: 35세, 대구 거주
```

### 예제 2: 함수 결과 처리

```python
# 여러 값 반환과 언패킹
def get_user_info():
    return "Alice", 30, "alice@example.com"

name, age, email = get_user_info()
print(f"{name}({age}): {email}")  # Alice(30): alice@example.com

# 일부만 필요할 때
name, *_ = get_user_info()
print(name)  # Alice
```

### 예제 3: API 응답 처리

```python
# API 응답 (딕셔너리) 처리
api_response = {
    "user": {
        "id": 1,
        "name": "Bob",
        "email": "bob@example.com"
    },
    "status": 200,
    "message": "success"
}

# 중첩 언패킹
{"user": {"name": user_name, "email": user_email}, "status": status} = api_response

print(f"사용자: {user_name}")
print(f"이메일: {user_email}")
print(f"상태: {status}")
```

### 예제 4: 데이터 변환 및 정렬

```python
# 데이터 구조 변환
data = [
    ("apple", 5),
    ("banana", 3),
    ("cherry", 8)
]

# 언패킹으로 새로운 형태로 변환
items_dict = {name: count for name, count in data}
print(items_dict)
# {'apple': 5, 'banana': 3, 'cherry': 8}

# 여러 시퀀스 동시 처리
names = ["a", "b", "c"]
ages = [20, 25, 30]
emails = ["a@ex.com", "b@ex.com", "c@ex.com"]

for name, age, email in zip(names, ages, emails):
    print(f"{name}: {age}세, {email}")
```

### 예제 5: 설정 관리

```python
# 기본값과 사용자 설정 병합
DEFAULT_CONFIG = {
    "debug": False,
    "port": 8000,
    "host": "localhost",
    "timeout": 30
}

user_config = {
    "debug": True,
    "port": 3000
}

# 기본값에 사용자 설정 적용
config = {**DEFAULT_CONFIG, **user_config}
print(config)
# {'debug': True, 'port': 3000, 'host': 'localhost', 'timeout': 30}
```

### 예제 6: 복잡한 함수 호출 체인

```python
# 함수 간에 데이터 전달
def fetch_data():
    """데이터 조회"""
    return [
        {"id": 1, "name": "Item1", "price": 100},
        {"id": 2, "name": "Item2", "price": 200}
    ]

def process_items(*items, **filters):
    """데이터 처리"""
    for item in items:
        if all(item.get(k) == v for k, v in filters.items() or True):
            yield item

def format_result(items, template=None):
    """결과 포맷팅"""
    for item in items:
        print(f"ID: {item['id']}, 이름: {item['name']}, 가격: {item['price']}")

# 체인 실행
data = fetch_data()
processed = process_items(*data)
format_result(processed)

# 출력:
# ID: 1, 이름: Item1, 가격: 100
# ID: 2, 이름: Item2, 가격: 200
```

### 예제 7: 상태 관리

```python
# 상태 업데이트 및 패킹
class StateManager:
    def __init__(self, **initial_state):
        self.state = initial_state
    
    def update(self, **changes):
        """상태 업데이트"""
        self.state = {**self.state, **changes}
    
    def get(self, *keys):
        """여러 값 조회"""
        return tuple(self.state.get(k) for k in keys)
    
    def display(self):
        name, age, city = self.get("name", "age", "city")
        print(f"{name}은 {age}세이고 {city}에 삽니다.")

# 사용
manager = StateManager(name="Charlie", age=35, city="Seoul")
manager.display()  # Charlie은 35세이고 Seoul에 삽니다.

manager.update(city="Busan")
manager.display()  # Charlie은 35세이고 Busan에 삽니다.
```

---

## 주의사항 및 베스트 프랙티스

### 1. 가독성 우선

```python
# 나쁜 예: 너무 많은 값 언패킹
a, b, c, d, e, f, g, h = some_function()

# 좋은 예: 필요한 값만 언패킹
first, second, *rest = some_function()

# 또는 명시적으로
result = some_function()
first = result[0]
second = result[1]
```

### 2. 타입 힌팅 활용

```python
from typing import Tuple, List

def process_tuple() -> Tuple[str, int, bool]:
    """반환 타입 명시"""
    return "Alice", 30, True

name: str
age: int
active: bool
name, age, active = process_tuple()

def flexible_args(*args: int, **kwargs: str) -> None:
    """가변 인자의 타입 명시"""
    pass
```

### 3. 예외 처리

```python
def safe_unpack(data, expected_length=None):
    try:
        if expected_length:
            a, b, *rest = data
        else:
            a, b = data
        return a, b
    except ValueError as e:
        print(f"언패킹 오류: {e}")
        return None, None

result = safe_unpack([1, 2, 3, 4], expected_length=True)
print(result)  # (1, 2)
```

### 4. 성능 고려

```python
# 큰 시퀀스의 경우 필요한 값만 언패킹
large_data = list(range(1000000))

# 나쁜 예: 모두 언패킹 시도
# a, *rest = large_data  # 메모리 비효율적

# 좋은 예: 필요한 부분만
first = large_data[0]
last = large_data[-1]
```

### 5. 명시성 유지

```python
# 나쁜 예: 의도가 불명확
first, second, *_ = data

# 좋은 예: 의도가 명확
first, second = data[0:2]  # 또는 more descriptive naming
first, second, *unused_values = data
```

---

## 연습 문제

### 문제 1: 기본 언패킹
다음 코드의 결과를 예측하시오.
```python
a, b, c = "ABC"
print(a, b, c)
```

### 문제 2: 확장 언패킹
다음을 완성하시오.
```python
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
# 결과: first=?, middle=?, last=?
```

### 문제 3: 함수 호출
다음 함수를 호출하는 올바른 방법은?
```python
def sum_values(a, b, c):
    return a + b + c

numbers = [10, 20, 30]
# 어떻게 호출할까?
```

### 문제 4: 딕셔너리 언패킹
다음을 완성하시오.
```python
person = {"name": "Eve", "age": 28, "city": "Incheon"}
name, age, city = ???
```

### 문제 5: 실전 문제
다음 함수를 만들어보시오.
```python
# 입력: 여러 딕셔너리
# 출력: 모든 딕셔너리를 병합한 결과
def merge_dicts(*dicts):
    pass

# 사용 예시
d1 = {"a": 1, "b": 2}
d2 = {"c": 3, "d": 4}
d3 = {"e": 5}
result = merge_dicts(d1, d2, d3)
# 결과: {'a': 1, 'b': 2, 'c': 3, 'd': 4, 'e': 5}
```

---

## 연습 문제 답안

### 답 1
```python
a, b, c = "ABC"
print(a, b, c)  # A B C
```

### 답 2
```python
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
# first=1, middle=[2, 3, 4], last=5
```

### 답 3
```python
def sum_values(a, b, c):
    return a + b + c

numbers = [10, 20, 30]
result = sum_values(*numbers)  # 60
```

### 답 4
```python
person = {"name": "Eve", "age": 28, "city": "Incheon"}
name, age, city = person.values()
# 또는
name = person["name"]
age = person["age"]
city = person["city"]
```

### 답 5
```python
def merge_dicts(*dicts):
    result = {}
    for d in dicts:
        result = {**result, **d}
    return result

# 또는 더 간단하게
def merge_dicts(*dicts):
    return {k: v for d in dicts for k, v in d.items()}
```

---

## 요약

| 기능 | 용도 | 예시 |
|------|------|------|
| **기본 언패킹** | 시퀀스를 변수에 할당 | `a, b = (1, 2)` |
| **확장 언패킹** | 남은 값들을 수집 | `a, *rest = [1, 2, 3]` |
| **`*args`** | 가변 위치 인자 수집 | `def func(*args)` |
| **`**kwargs`** | 가변 키워드 인자 수집 | `def func(**kwargs)` |
| **호출 시 언패킹** | 시퀀스/딕셔너리를 인자로 전달 | `func(*list)` 또는 `func(**dict)` |
| **딕셔너리 병합** | 여러 딕셋을 병합 | `{**dict1, **dict2}` |

---

## 추가 학습 자료

- Python 공식 문서: https://docs.python.org/3/tutorial/datastructures.html#tuples-and-sequences
- PEP 3132 (Extended Unpacking): https://www.python.org/dev/peps/pep-3132/
- Python 3.10 패턴 매칭: https://docs.python.org/3/whatsnew/3.10.html#structural-pattern-matching

